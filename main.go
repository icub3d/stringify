// Program stringify is a replacement of stringer that produces
// lintable and testable string representations of constants.
//
// It accepts exactly one const type to stringify and works within the
// file from which generate was run. For more details, see the
// README.md.
//
// Suppose you have a file named message.go with the contents below.
//
//   package message
//
//   //go:generate stringify EventLevel
//
//   // EventLevel is the level for an Event.
//   type EventLevel int32
//
//   // These are the event levels, based on syslog.
//   const (
//     Emerg EventLevel = iota
//     Alert
//     Crit
//     Err
//     Warning
//     Notice
//     Info
//     Debug
//   )
//
// Running go generate would produce a file named
// eventlevel_stringify.go and eventlevel_stringify_test.go that
// contains EventLevel.String() and NewEvent() functions as well as
// tests for those functions. Most notably, they should have 100% code
// coverage and pass vetting and linting.
package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/constant"
	"go/format"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// Const is the name and value of a constant to be output to the
// templates below.
type Const struct {
	Ident string
	Value string
}

// Data is the data for the templates below.
type Data struct {
	Package string
	File    string
	Path    string
	Name    string
	Unused  string
	Consts  []Const
}

// FindUnused is a helper function to find an unused value for
// testing.
func (d *Data) findUnused() {
Outer:
	for {
		i := fmt.Sprintf("%d", rand.Int31())
		for _, c := range d.Consts {
			if c.Value == i {
				continue Outer
			}
		}
		d.Unused = i
		return
	}
}

// SrcTmpl is the template for the source file. It will go through
// gofmt before being output.
var srcTmpl = template.Must(
	template.New("src").Parse(`// Generated by stringify. DO NOT EDIT!
// Generated from {{.File}} for const {{.Name}}.

package {{.Package}}

import "fmt"

// String implmenents the fmt.Stringer interface.
func (c {{.Name}}) String() string {
  switch c { 
  {{range .Consts}}case {{.Ident}}: return "{{.Ident}}";{{end}}
default: return fmt.Sprintf("{{.Name}}(%d)", c)
  }
}

// New{{.Name}} returns a {{.Name}} based on the given name. If the 
// name doesn't match any value, the zero-value is returned.
func New{{.Name}}(name string) {{.Name}} {
  switch name {
  {{range .Consts}}case "{{.Ident}}": return {{.Ident}};{{end}}
  default: return {{.Name}}(0)
  }
}
`))

// TestTmpl is the template for the source file. It will go through
// gofmt before being output.
var testTmpl = template.Must(
	template.New("test").Parse(`// Generated by stringify. DO NOT EDIT!
// Generated from {{.File}} for const {{.Name}}.

package {{.Package}}

import "testing"

func Test{{.Name}}String(t *testing.T) {
  {{range .Consts}}if {{$.Name}}({{.Value}}).String() != "{{.Ident}}" {
  t.Errorf("{{$.Name}}({{.Value}}).String() != \"{{.Ident}}\"")
}
{{end}}//Test the default case.
if {{.Name}}({{.Unused}}).String() != "{{.Name}}({{.Unused}})" {
  t.Errorf("{{.Name}}({{.Unused}}).String() != \"{{.Name}}({{.Unused}})\"")
}
}

func TestNew{{.Name}}(t *testing.T) {
  {{range .Consts}}if New{{$.Name}}("{{.Ident}}") != {{$.Name}}({{.Value}}) {
  t.Errorf("New{{$.Name}}(\"{{.Ident}}\") != {{$.Name}}({{.Value}})")
}
{{end}}//Test the default case.
if New{{.Name}}("{{.Unused}}") != {{.Name}}(0) {
  t.Errorf("New{{.Name}}(\"{{.Unused}}\") != {{.Name}}(0)")
}
}
`))

func main() {
	// We use log because most of the logging we'd do should cause an
	// os.Exit().
	log.SetFlags(0)
	log.SetPrefix("stringify: ")

	// Determine where we are and where we'll be storing the new files.
	dir, err := os.Getwd()
	if err != nil {
		log.Fatalln("getting working directory:", err)
	}

	// Setup the data container we'll pass to the templates.
	data := &Data{
		Package: os.Getenv("GOPACKAGE"),
		File:    os.Getenv("GOFILE"),
		Path:    filepath.Join(dir, os.Getenv("GOFILE")),
		Name:    os.Args[1],
		Consts:  []Const{},
	}

	// Parse the source.
	fs := token.NewFileSet()
	parsed, err := parser.ParseFile(fs, data.Path, nil, 0)
	if err != nil {
		log.Fatalf("parsing file '%v': %v", data.Path, err)
	}

	// Check the parsed file and get the definitions and types.
	defs := map[*ast.Ident]types.Object{}
	config := types.Config{Importer: importer.Default()}
	info := &types.Info{Defs: defs}
	_, err = config.Check(data.Package, fs, []*ast.File{parsed}, info)
	if err != nil {
		log.Fatalf("checking file '%v': %v", data.Path, err)
	}

	// Discover all of the related consts.
	ast.Inspect(parsed, func(n ast.Node) bool {
		// Exit when we are not in a const token.
		decl, ok := n.(*ast.GenDecl)
		if !ok || decl.Tok != token.CONST {
			return true
		}

		// Loop through the specs searching for our named const.
		typ := ""
		for _, spec := range decl.Specs {
			vspec := spec.(*ast.ValueSpec)

			// Type without a value.
			if vspec.Type == nil && len(vspec.Values) > 0 {
				typ = ""
				continue
			}

			// If we received a type, make sure it's ours.
			if vspec.Type != nil {
				id, ok := vspec.Type.(*ast.Ident)
				if !ok {
					continue
				}
				typ = id.Name
			}
			if typ != data.Name {
				continue
			}

			// Loop through the name/value pairs of our type and store them.
			for _, name := range vspec.Names {
				if name.Name == "_" {
					continue
				}
				obj, ok := defs[name]
				if !ok {
					log.Fatalln("no value for constant", name)
				}
				info := obj.Type().Underlying().(*types.Basic).Info()
				if info&types.IsInteger == 0 {
					log.Fatalln("non-integer type", typ)
				}
				value := obj.(*types.Const).Val()
				if value.Kind() != constant.Int {
					log.Fatalln("non-integer contstant", name)
				}
				data.Consts = append(data.Consts, Const{name.Name, value.String()})
			}
		}
		return false
	})

	// Determine an unused value for use with the testing file.
	data.findUnused()

	// Write out our source file.
	buf := &bytes.Buffer{}
	srcFile := strings.ToLower(data.Name) + "_stringify.go"
	err = srcTmpl.ExecuteTemplate(buf, "src", data)
	if err != nil {
		log.Fatalln("templating src:", err)
	}
	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalln("formatting source:", err)
	}
	err = ioutil.WriteFile(srcFile, src, 0644)
	if err != nil {
		log.Fatalf("writing file '%v': %v", srcFile, err)
	}

	// Write out our test file.
	buf.Reset()
	testFile := strings.ToLower(data.Name) + "_stringify_test.go"
	err = testTmpl.ExecuteTemplate(buf, "test", data)
	if err != nil {
		log.Fatalln("templating test:", err)
	}
	test, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalln("formatting test:", err)
	}
	err = ioutil.WriteFile(testFile, test, 0644)
	if err != nil {
		log.Fatalf("writing file '%v': %v", testFile, err)
	}
}
